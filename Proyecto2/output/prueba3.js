/** **** FILE AUTOGENERATED ***** */

const { RegParser } = require('../lib/FAClasses');
const { TOKEN_TYPE } = require('../lib/constants');
const LexicalAnalyzer = require('../lib/LexerClass/LexicalAnalyzer');

const filePath = process.argv.slice(2)[0];

const keyWordsRegEx = [{ name: 'si', value: 'if' }, { name: 'para', value: 'for' }, { name: 'mientras', value: 'while' }, { name: 'MIENTRAS', value: 'WHILE' }, { name: 'Mientras', value: 'While' }];
const tokensRegEx = [{ name: 'identificador', value: '(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)((a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)|(0|1|2|3|4|5|6|7|8|9|0))*' }, { name: 'numero', value: '(0|1|2|3|4|5|6|7|8|9|0)((0|1|2|3|4|5|6|7|8|9|0))*' }, { name: 'numeroDecimal', value: '(0|1|2|3|4|5|6|7|8|9|0)((0|1|2|3|4|5|6|7|8|9|0))*.(0|1|2|3|4|5|6|7|8|9|0)((0|1|2|3|4|5|6|7|8|9|0))*' }, { name: 'numeroHex', value: '(0|1|2|3|4|5|6|7|8|9|0)+(A|B|C|D|E|F)((0|1|2|3|4|5|6|7|8|9|0)+(A|B|C|D|E|F))*H' }, { name: 'espacioEnBlanco', value: 'CHR(9)+CHR(32)(CHR(9)+CHR(32))*' }, {
  name: 'cadena', value: '(a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)+(0|1|2|3|4|5|6|7|8|9|0)',
}];

// Create keyWords DFA
const keyWordsFSM = keyWordsRegEx.map((keyWord) => {
  const parser = new RegParser(keyWord.value);
  const { nfa } = parser.parseToNFA();
  const { dfa } = nfa.toDFA();

  return {
    name: keyWord.name,
    fsm: dfa,
  };
});

// Create tokens DFA
const tokensFSM = tokensRegEx.map((keyWord) => {
  const parser = new RegParser(keyWord.value);
  const { nfa } = parser.parseToNFA();
  const { dfa } = nfa.toDFA();

  return {
    name: keyWord.name,
    fsm: dfa,
  };
});

// Build Lexer
const lexer = new LexicalAnalyzer(filePath, keyWordsFSM, tokensFSM);

let token = lexer.nextToken();

while (token !== TOKEN_TYPE.END) {
  console.log(token);
  token = lexer.nextToken();
}
